= XML-RPC for PHP User Manual
:revision: 4.9.3
:keywords: xmlrpc, xml, rpc, webservices, http
:toc: left
:imagesdir: images
:source-highlighter: highlightjs


== Files in the distribution [[manifest]]

debugger/*:: a graphical debugger which can be used to test calls to xml-rpc servers

demo/*:: example code for implementing both client and server functionality. Only included when installing with `--prefer-install=source`

doc/*:: the documentation, including this manual, and the list of API changes between versions 3 and 4

extras/*:: php utility scripts, such as a benchmark suite and an environment compatibility checker. Only included when installing with `--prefer-install=source`

lib/*:: a compatibility layer for applications which still rely on version 3 of the API

src/*:: the XML-RPC library classes. You can autoload these via Composer, or via a dedicated Autoloader class

tests/*:: the test suite for the library, written using PhpUnit, and the configuration to run it in a local Docker container. Only included when installing with `--prefer-install=source`


== A foreword [[foreword]]

You might be surprised by some API design choices made by this library. In order to understand that, please keep
in mind that this started out as a bare framework around the time of PHP 3, when Exceptions and the DateTime class did
not exist, and PHP best practices were remarkably different from current ones. While many "nice bits" have been put in
over time, __backwards compatibility has always taken precedence__ over API cleanups.

In no particular order, this is partial list of things some developers might find perplexing.

Extensions to the XML-RPC protocol, such as support for the `<NIL>` tag, have to be manually enabled before usage.

Little HTTP response checking is performed (e.g. HTTP redirects are not followed by default and the Content-Length
HTTP header, mandated by the xml-rpc spec, is not validated); cookie support still involves quite a bit of coding on
the part of the user.

Very little type validation or coercion has been put in. PHP being a loosely-typed language, this is going to have to be
done explicitly (in other words: you can call a lot of library functions passing them arguments of the wrong type and
receive an error message only much further down the code, where it will be difficult to understand).

dateTime.iso8601 is supported opaquely, largely for historical reasons. Datetime conversion can't be done transparently
as the XML-RPC specification explicitly forbids passing of timezone specifiers in ISO8601 format dates. You can, however,
use the `PhpXmlRpc\Helper\Date` class to do the encoding and decoding for you.

Most class members have "public" access, even those only meant for internal usage.

There are a lot of static class variables which are meant be treated as if they were constants.

Usage of Exceptions is almost non-existent.

A mix of snake_case and CamelCase naming is used.


== API usage [[apidocs]]

=== Type conversion [[types]]

A big part the job of this library is to convert between the data types supported by PHP (`null`, `bool`, `int`, `float`,
`string`, `array`, `object`, `callable`, `resource`), and the value types supported by XML-RPC (`int`, `boolean`, `string`,
`double`, `dateTime.iso8601`, `base64`, `struct`, `array`).

The conversion process can be mostly automated or fully manual. It is up to the single developer to decide the best
approach to take for his/her application.

==== Manual type conversion: PHP to XML-RPC [[value]]

The `PhpXmlRpc\Value` class is used to encapsulate PHP primitive types into XML-RPC values.

The constructor is the normal way to create a Value. The constructor can take these forms:

    Value new Value
    Value new Value(string $stringVal)
    Value new Value(mixed $scalarVal, string $scalarTyp)
    Value new Value(Value[] $arrayVal, string $arrayTyp)

The first constructor creates an empty value, which must be altered using the methods `addScalar()`, `addArray()` or
`addStruct()` before it can be used further.

The second constructor creates a string scalar value.

The third constructor is used to create a scalar value of any type. The second parameter must be a name of an XML-RPC type.
Valid types are: "int", "i4", "i8", "boolean", "double", "string", "dateTime.iso8601", "base64" or "null". For ease of use,
and to avoid compatibility issues with future revisions of the library, they are also available as static class variables:

[source, php]
----
Value::$xmlrpcI4 = "i4";
Value::$xmlrpcI8 = "i8";
Value::$xmlrpcInt = "int";
Value::$xmlrpcBoolean = "boolean";
Value::$xmlrpcDouble = "double";
Value::$xmlrpcString = "string";
Value::$xmlrpcDateTime = "dateTime.iso8601";
Value::$xmlrpcBase64 = "base64";
Value::$xmlrpcArray = "array";
Value::$xmlrpcStruct = "struct";
Value::$xmlrpcValue = "undefined";
Value::$xmlrpcNull = "null";
----

Examples:

[source, php]
----
use PhpXmlRpc\Value;

$myString = new Value("Hello, World!");
$myInt = new Value(1267, "int");
$myBool = new Value(1, Value::$xmlrpcBoolean);
$myString2 = new Value(1.24, Value::$xmlrpcString); // note: this will serialize a php float value as xml-rpc string
$myBase64 = new Value(file_get_contents('my.gif'), Value::$xmlrpcBase64); // the lib will take care of base64 encoding
$myDate1 = new Value(new DateTime(), Value::$xmlrpcDateTime);
$myDate2 = new Value(time(), Value::$xmlrpcDateTime); // when passing in an int, it is assumed to be a UNIX timestamp
$myDate3 = new Value(date("Ymd\TH:i:s", time()), Value::$xmlrpcDateTime); // when passing in a string, you have to take care of the formatting
----

The fourth constructor form can be used to compose complex XML-RPC values. The first argument is either a simple array
in the case of an XML-RPC array or an associative array in the case of a struct. __The elements of the array must be
Value objects themselves__. The second parameter must be either "array" or "struct".

Examples:

[source, php]
----
use PhpXmlRpc\Value;

$myArray = new Value(
    array(
        new Value("Tom"),
        new Value("Dick"),
        new Value("Harry")
    ),
    "array"
);

// nested struct
$myStruct = new Value(
    array(
        "name" => new Value("Tom", Value::$xmlrpcString),
        "age" => new Value(34, Value::$xmlrpcInt),
        "address" => new Value(
            array(
                "street" => new Value("Fifht Ave", Value::$xmlrpcString),
                "city" => new Value("NY", Value::$xmlrpcString)
            ),
            Value::$xmlrpcStruct
        )
    ),
    Value::$xmlrpcStruct
);
----

==== Manual type conversion: XML-RPC to PHP

For Value objects of scalar type, the php primitive value can be obtained via the `scalarval()` method. For base64 values,
the returned value will be decoded transparently. __NB: for dateTime values the php value will be the string representation
by default.__

Value objects of type struct and array support the `Countable`, `IteratorAggregate` and `ArrayAccess` interfaces, meaning
that they can be manipulated as if they were arrays:

[source, php]
----
if (count($structValue)) {
    foreach($structValue as $elementName => $elementValue) {
        echo "Struct member '$elementName' is of type " . $elementValue->scalartyp() . "\n"; // do not forget html-escaping $elementName in real life!
    }
} else {
    echo "Struct has no members\n";
}
----

As you can see, the elements of the array are Value objects themselves, i.e. there is no recursive decoding happening.

==== Automatic type conversion: PHP to XML-RPC

Manually converting the data from PHP to Value objects can become quickly tedious, especially for large, nested data
structures such as arrays and structs. A simpler alternative is to take advantage of the `PhpXmlRpc\Encoder` class to
carry out automatic conversion of arbitrarily deeply nested structures. The same structure of the example above can be
obtained via:

[source, php]
----
use PhpXmlRpc\Encoder;

$myStruct = new Encoder()->encode([
    "name" => "Tom",
    "age" => 34,
    "address" => [
        "street" => "Fifht Ave",
        "city" => "NY"
    ],
]);
----

Encoding works recursively on arrays and objects, encoding numerically indexed php arrays into array-type Value objects
and non numerically indexed php arrays into struct-type Value objects. PHP objects are encoded into struct-type Value by
iterating over their public properties, excepted for those that are already instances of the Value class or descendants
thereof, which will not be further encoded. Optionally, encoding of date-times is carried-on on php strings with the
corresponding format, as well as encoding of NULL values. Note that there's no support for encoding php values into base64
values - base64 Value objects have to be created manually (but they can be part of a php array passed to `encode`).
Another example, showcasing some of those features:

[source, php]
----
use PhpXmlRpc\Encoder;
use PhpXmlRpc\Value;

$value = new Encoder()->encode(
    array(
        'first struct_element: a null' => null,
        '2nd: a base64 element' => new Value('hello world', 'base64'),
        '3rd: a datetime' => '20060107T01:53:00'
    ),
    array('auto_dates', 'null_extension')
);
----

See the https://gggeek.github.io/phpxmlrpc/doc-4/api/classes/PhpXmlRpc-Encoder.html#method_encode[phpdoc documentation]
for `PhpXmlRpc\Encoder::encode` for more details on the encoding process and available options.

==== Automatic type conversion: XML-RPC to PHP

In the same vein, it is possible to automatically convert arbitrarily nested Value objects into native PHP data by using
the `PhpXmlRpc\Encoder::decode` method.

A similar example to the manual decoding above would look like:

[source, php]
----
use PhpXmlRpc\Encoder;

$data = new Encoder()->decode($structValue);
if (count($data)) {
    foreach($data as $elementName => $element) {
        echo "Struct member '$elementName' is of type " . gettype($element) . "\n"; // do not forget html-escaping $elementName in real life!
    }
} else {
    echo "Struct has no members\n";
}
----

Note that when using automatic conversion this way, all information about the original xml-rpc type is lost: it will be
impossible to tell apart an `i4` from an `i8` value, or to know if a php string had been encoded as xml-rpc string or as
base64.

See the https://gggeek.github.io/phpxmlrpc/doc-4/api/classes/PhpXmlRpc-Encoder.html#method_encode[phpdoc documentation]
for `PhpXmlRpc\Encoder::decode` for the full details of the decoding process.

==== Notes on types

===== base64

Base 64 encoding is performed transparently to the caller when using this type. Decoding is also transparent.
Therefore, you ought to consider it as a "binary" data type, for use when you want to pass data that is not XML-safe.

===== boolean

All php values which would be converted to a boolean TRUE via typecasting are mapped to an xml-rpc `true`. All other
values (including the empty string) are converted to `false`.

===== dateTime

When manually creating Value objects representing an xml-rpc dateTime.iso8601, php integers, strings and DateTimes can be
used as source values. For those, the original value will be returned when calling `+$value->scalarval();+`.

When Value objects are created by the library by parsing some received XML text, all Value objects representing an xml-rpc
dateTime.iso8601 value will return the string representation of the date when calling `+$value->scalarval();+`.

Datetime conversion can't be safely done in a transparent manner as the XML-RPC specification explicitly forbids passing
of timezone specifiers in ISO8601 format dates. You can, however, use the `PhpXmlRpc\Helper\Date` class to decode the date
string into a unix timestamp, or use the `PhpXmlRpc\Encoder::decode` method with the 'dates_as_objects' option to get
back a php DateTime (in which case the conversion is done using the `strtotime` function, which uses the timezone set in
php.ini).

===== double

The xml-rpc spec explicitly forbids using exponential notation for doubles. The phpxmlrpc toolkit serializes php float
values using a fixed precision (number of decimal digits), which can be set using the variable
`PhpXmlRpc::$xmlpc_double_precision`.

===== int

The xml parsing code will always convert "i4" to "int": int is regarded by this implementation as the canonical name for
this type.

The type i8 on the other hand is considered as a separate type. Note that the library will never output integers as 'i8'
on its own, even when php is compiled in 64-bit mode - you will have to create i8 Value objects manually if required.

===== string

When serializing strings, characters '<', '>', ''', '"', '&', are encoded using their entity reference as '\&lt;', '\&gt;',
'\&apos;', '\&quot;' and '\&amp;'. All other characters outside the ASCII range are encoded using their unicode character
reference representation (e.g. '\&#200;' for 'é'). The XML-RPC spec recommends only encoding '<' and '&', but this
implementation goes further, for reasons explained by the http://www.w3.org/TR/REC-xml#syntax[XML 1.0 recommendation].
In particular, using character reference representation has the advantage of producing XML that is valid independently of
the charset encoding assumed.

Note that, despite what the specification states, string values should not be used to encode binary data, as control
characters (such as f.e. characters nr. 0 to 8) are never allowed in XML, even when encoded as character references.

In case the string data you are using is mostly outside the ASCII range, such as f.e. when communicating information
in chinese, japanese, or korean, you might want to avoid the automatic encoding of all non-ascii characters to references,
as it has performance implications, both in cpu usage and in the size of the generated messages. For such scenarios, it
is recommended to set both `PhpXmlRpc::$xmlrpc_internalencoding` and `+$client->request_charset_encoding+` /
`+$server->response_charset_encoding+` to 'UTF-8';

===== null

There is no support for encoding `null` values in the XML-RPC spec, but at least a couple of extensions (and many
toolkits) do support it. Before using `null` values in your messages, make sure that the remote party accepts
them, and uses the same encoding convention.

To allow reception of messages containing `<NIL/>` or `<EX:NIL/>` elements, set

    PhpXmlRpc\PhpXmlRpc::$xmlrpc_null_extension = true;

somewhere in your code before the messages are received.

To allow sending of messages containing `<NIL/>` elements, simply create Value objects using the string 'null' as the
2nd argument in the constructor. If you'd rather have those null Values be serialized as `<EX:NIL/>` instead of `<NIL/>`,
please set

    PhpXmlRpc\PhpXmlRpc::$xmlrpc_null_apache_encoding = true;

somewhere in your code before the values are serialized.

=== Client [[client]]

==== Client creation

The constructor accepts one of two possible syntax forms:

    Client new Client(string $server_url)
    Client new Client(string $server_path, string $server_hostname, int $server_port = 80, string $transport = 'http')

Here are a couple of usage examples of the first form:

[source, php]
----
use PhpXmlRpc\Client;

$client = new Client("https://phpxmlrpc.sourceforge.net/server.php");
$another_client = new Client("https://james:bond@secret.service.com:443/xmlrpcserver?agent=007");
----

Note that 'http11', 'http10', 'h2' (for HTTP2) and 'h2c' can be used as valid alternatives to 'http' and 'https' in the provided url.

The second syntax does not allow to express a username and password to be used for basic HTTP authorization as in the
second example above, but instead it allows to choose whether xml-rpc calls will be made using the HTTP protocol version
1.0, 1.1 or 2.

Here's another example client set up to query Userland's XML-RPC server at __betty.userland.com__:

[source, php]
----
use PhpXmlRpc\Client;

$client = new Client("/RPC2", "betty.userland.com", 80);
----

The `$server_port` parameter is optional, and if omitted will default to '80' when using HTTP and '443' when using HTTPS
or HTTP2.

The `$transport` parameter is optional, and if omitted will default to 'http'. Allowed values are either 'http', 'https',
'http11', 'http10', 'h2' or 'h2c'. Its value can be overridden with every call to the `send()` method. See the
https://gggeek.github.io/phpxmlrpc/doc-4/api/classes/PhpXmlRpc-Client.html#method_send[phpdoc documentation] for the send
method for more details about the meaning of the different values.

==== Sending requests

The Client's `send` method takes a `PhpmlRpc\Request` object as first argument, and always returns a `PhpmlRpc\Response`
one, even in case of errors communicating with the server.

[source, php]
----
use PhpXmlRpc\Client;
use PhpXmlRpc\Request;
use PhpXmlRpc\Value;

$stateNo = (int)$_POST["stateno"];
$req = new Request('examples.getStateName', array(new Value($stateNo, Value::$xmlrpcInt)));
$client = new Client("https://phpxmlrpc.sourceforge.net/server.php");
$resp = $client->send($req);
if (!$resp->faultCode()) {
    $v = $resp->value();
    print "State number $stateNo is " . htmlentities($v->scalarval()) . "<BR>";
    print "<HR>I got this xml back<BR><PRE>" . htmlentities($resp->serialize()) . "</PRE><HR>\n";
} else {
    print "Fault <BR>";
    print "Code: " . htmlentities($resp->faultCode()) . "<BR>" . "Reason: '" . htmlentities($resp->faultString()) . "'<BR>";
}
----

==== Automatic decoding of the response's value

By default, the Response object's `value()` method will return a Value object, leaving it to the developer to unbox it
further into php primitive types. In the spirit of making the conversion between the xml-rpc types and php native types
as simple as possible, it is possible to make the Client object return directly the decoded data by setting a value to
the `$client->return_type` property:

[source, php]
----
use PhpXmlRpc\Client;
use PhpXmlRpc\Helper\XMLParser;
use PhpXmlRpc\Request;
use PhpXmlRpc\Value;

$stateNo = (int)$_POST["stateno"];
$req = new Request('examples.getStateName', array(new Value($stateNo, Value::$xmlrpcInt)));
$client = new Client("https://phpxmlrpc.sourceforge.net/server.php");
$client->return_type = XMLParser::RETURN_PHP;
$resp = $client->send($req);
if (!$resp->faultCode()) {
    $v = $resp->value();
    print "State number $stateNo is " . htmlentities($v) . "<BR>"; // no need to call `scalarval` here
    print "<HR>I got this xml back<BR><PRE>" . htmlentities($resp->serialize()) . "</PRE><HR>\n";
} else {
    print "Fault <BR>";
    print "Code: " . htmlentities($resp->faultCode()) . "<BR>" . "Reason: '" . htmlentities($resp->faultString()) . "'<BR>";
}
----

This style of making calls will result in reduced memory and cpu usage, and be slightly faster. It is recommended for
scenarios where the expected responses are huge, or every little bit of optimization is required.

Please note that, just as with the `PhpXmlRpc\Encoder::decode` method, this will make it impossible to tell apart
values which were sent over the wire as strings from values which were base64. On the other hand, unlike that method,
at the moment it is not possible to make use of any options to tweak the decoding process.

==== Troubleshooting failed calls

To ease troubleshooting problems related to the underlying communication layer, such as authentication failures,
character set encoding snafus, compression problems, invalid xml, etc..., the Client class can dump to the screen a
detailed log of the HTTP request sent and response received. It can be enabled by calling the `setDebug` method with
values `1` or `2`.

It is also possible to analyze the different parts of the HTTP response received by making use of the
`PhpXmlRpc\Response::httpResponse` method.

==== Modifying the client's behaviour

A wide range of options can be set to the client to manage the details of the HTTP communication layer, including
authentication (Basic, Digest, NTLM), SSL certificates, proxies, cookies, compression of the requests, usage of keepalives
for consecutive calls, the accepted response compression, charset encoding used for the requests and the user-agent string.

See the https://gggeek.github.io/phpxmlrpc/doc-4/api/classes/PhpXmlRpc-Client.html[phpdoc documentation] for details on
all of those.

===== cURL vs socket calls

Please note that, depending on the HTTP protocol version used and the options set to the client, the client will
transparently switch between using a socket-based HTTP implementation and a cURL based implementation. If needed, you
can make use of the `setUseCurl` method to force or disable usage of the cURL based implementation.

When using cURL as the underlying transport, it is possible to set directly into the client any of the cURL options
available in your php installation, via the `setCurlOptions` method.

==== Sending multiple requests

Both the Client and Server classes provided by the library support the multicall xmlrpc extension, which allows to execute
multiple xml-rpc requests with a single http call, by wrapping them up in a call to the  `system.multiCall` method.

The expected advantage is a nice improvements in performances, especially when there are many small requests at play, but,
as always, the devil is in the details: the multicall specification does not mandate for the server to execute the
single requests within the multicall method in a specific order, nor how to handle execution errors happening halfway
through the list.

The phpxmlrpc server will execute all the requests sequentially, in the same order in which they appear in the xml payload,
and will try its best to execute them all, even if one of them fails, but there is no guarantee on the latter point.

In order to take advantage of multicall, either use the Client's `multicall` method, or just pass an array of Request to
the `send` method:

----
$m1 = new PhpXmlRpc\Request('system.methodHelp');
$m2 = new PhpXmlRpc\Request('system.methodSignature');
$val = new PhpXmlRpc\Value('an-xmlrpc-method', "string");
$m1->addParam($val);
$m2->addParam($val);
$ms = array($m1, $m2);
$rs = $client->multicall($ms);
foreach($rs as $resp) {
    var_dump($rs->faultCode());
    var_dump($rs->value());
}
----

Please note that, in case of faults during execution of a multicall call, the Client will automatically fail back to
sending every request separately, one at a time. If you are sure that the server supports the multicall protocol, you
might want to optimize and avoid this second attempt by passing `false` as 4th argument to `multicall()`.

If, on the other hand, after writing code which uses the `multicall` method, you are forced to migrate to a server which
does not support the `system.multiCall` method, you can simply set `$client->no_multicall = true`

=== Server [[server]]

The implementation of this class has been kept as simple to use as possible. The constructor for the server basically
does all the work. Here's a minimal example:

[source, php]
----
use PhpXmlRpc\Request;
use PhpXmlRpc\Response;
use PhpXmlRpc\Server;

function foo(Request $xmlrpc_request) {
    ...
    return new Response($some_xmlrpc_val);
}

class Bar {
    public static function fooBar(Request $xmlrpc_request) {
        ...
        return new Response($some_xmlrpc_val);
    }
}

$s = new Server(
    array(
        "examples.myFunc1" => array("function" => "foo"),
        "examples.myFunc2" => array("function" => "Bar::fooBar"),
    )
);
----

This performs everything you need to do with a server. The single constructor argument is an associative array
from xml-rpc method names to php callables.

==== The dispatch map

The first argument to the Server constructor is an array, called the __dispatch map__.
In this array is the information the server needs to service the XML-RPC methods you define.

The dispatch map takes the form of an associative array of associative arrays: the outer array has one entry for each
method, the key being the method name. The corresponding value is another associative array, which can have the following
members:

* `function` - this entry is mandatory. It must be a callable: either a name of a function in the global scope which
  services the XML-RPC method, an array containing an instance of an object and a method name, or an array containing
  a class name and a static method name (for static class methods the '$class::$method' syntax is also supported).

* `signature` - this entry is an array containing the possible signatures (see <<signatures>>) for the method. If this
  entry is present then the server will check that the correct number and type of parameters have been sent for this
  method before dispatching it.

* `docstring` - this entry is a string containing documentation for the method. The documentation may contain HTML
  markup.

* `signature_docs` - this entry can be used to provide documentation for the single parameters. It must match
  in structure the 'signature' member. By default, only the `documenting_xmlrpc_server` class in the extras package will
  take advantage of this, since the `system.methodHelp` protocol does not support documenting method parameters individually.

* `parameters_type` - this entry can be used when the server is working in 'xmlrpcvals' mode (see <<method_handlers>>)
  to define one or more entries in the dispatch map as being functions that follow the 'phpvals' calling convention.
  The only useful value is currently the string 'phpvals'.

Methods `system.listMethods`, `system.methodHelp`, `system.methodSignature` and `system.multicall` are already defined
by the server, and should not be reimplemented (see <<reservedmethods>> below).

==== Method signatures [[signatures]]

A signature is a description of a method's return type and its parameter types. A method may have more than one
signature.

Within a server's dispatch map, each method has an array of possible signatures. Each signature is an array, with the
first element being the return type, and the others being the types of the parameters. For instance, the method

[source]
----
string examples.getStateName(int)
----

has the signature

[source, php]
----
use PhpXmlRpc\Value;

array(Value::$xmlrpcString, Value::$xmlrpcInt)
----

and, assuming that it is the only possible signature for the method, it might be used like this in server creation:

[source, php]
----
use PhpXmlRpc\Server;
use PhpXmlRpc\Value;

$findstate_sig = array(array(Value::$xmlrpcString, Value::$xmlrpcInt));

$findstate_doc = 'When passed an integer between 1 and 51 returns the name of a US state, where the integer is the index' .
    'of that state name in an alphabetic order.';

$srv = new Server(array(
    "examples.getStateName" => array(
        "function" => "...",
        "signature" => $findstate_sig,
        "docstring" => $findstate_doc
    )
));
----

Note that method signatures do not allow to check nested parameters, e.g. the number, names and types of the members of
a struct param cannot be validated.

If a method that you want to expose has a definite number of parameters, but each of those parameters could reasonably
be of multiple types, the list of acceptable signatures will easily grow into a combinatorial explosion. To avoid such
a situation, the lib defines the class property `Value::$xmlrpcValue`, which can be used in method signatures as a placeholder
for 'any xml-rpc type':

[source, php]
----
use PhpXmlRpc\Server;
use PhpXmlRpc\Value;

$echoback_sig = array(array(Value::$xmlrpcValue, Value::$xmlrpcValue));

$findstate_doc = 'Echoes back to the client the received value, regardless of its type';

$srv = new Server(array(
    "echoBack" => array(
        "function" => "...",
        "signature" => $echoback_sig, // this sig guarantees that the method handler will be called with one and only one parameter
        "docstring" => $echoback_doc
    )
));
----

==== Method handler functions [[method_handlers]]

The same php function can be registered as handler of multiple xml-rpc methods.

No text should be echoed 'to screen' by the handler function, or it will break the xml response sent back to the client.
This applies also to error and warning messages that PHP prints to screen unless the appropriate settings have been
set in `php.ini`, namely `display_errors`. Another way to prevent echoing of errors inside the response and
facilitate debugging is to use the server's `SetDebug` method with debug level 3 (see <<setdebug>>).

Exceptions thrown during execution of handler functions are caught by default and an XML-RPC error response is generated
instead. This behaviour can be fine-tuned by usage of the `$exception_handling` server property (see <<exception_handling>>).

===== Manual type conversion

In this mode of operation, the incoming request is parsed into a `Request` object and dispatched to the relevant php
function, which is responsible for returning a `Response` object, that will be serialized back to the caller.
The synopsis of a method handler function is thus:

    Response $resp = function(Request $req)

Note that if you implement a method with a name prefixed by `system.` the handler function will be invoked by the
server with two parameters, the first being the server itself and the second being the Request object.

Here is a more detailed example of what a handler function "foo" might do:

[source, php]
----
use PhpXmlRpc\PhpXmlRpc;
use PhpXmlRpc\Response;
use PhpXmlRpc\Value;

function foo ($xmlrpcreq)
{
    $meth = $xmlrpcreq->method(); // retrieve method name
    $par = $xmlrpcreq->getParam(0); // retrieve value of first parameter - assumes at least one param received
    $val = $par->scalarval(); // decode value of first parameter - assumes it is a scalar value

    // note that we could also have achieved the same this way:
    //$val = new PhpXmlRpc\Encoder()->decode($xmlrpcreq)[0];

    ...

    if ($err) {
        // this is an error condition
        return new Response(
            null,
            PhpXmlRpc::$xmlrpcerruser + 1, // user error 1
            "There's a problem, Captain"
        );
    } else {
        // this is a successful value being returned
        return new Response(new Value("All's fine!"));
    }
}
----

===== Automatic type conversion

In the same spirit of simplification that inspired the Client's `$return_type` property, a similar property
is available within the server class: `$functions_parameters_type`. When set to the string 'phpvals', the functions
registered in the server dispatch map will be called with plain php values as parameters, instead of a single Request
instance parameter. The return value of those functions is expected to be a plain php value, too. An example is worth a
thousand words:

[source, php]
----
use PhpXmlRpc\PhpXmlRpc;
use PhpXmlRpc\Server;
use PhpXmlRpc\Value;

function foo($usr_id, $out_lang='en')
{
    ...

    if ($someErrorCondition)
        throw new \Exception('DOH!', PhpXmlRpc::$xmlrpcerruser+1);
    else
        return array(
            'name' => 'Joe',
            'age' => 27,
            'picture' => new Value(file_get_contents($picOfTheGuy), 'base64'), // it is possible to mix php values and Value objects!
        );
}

$srv = new Server(
    array(
        "examples.myFunc" => array(
            "function" => "foo",
            "signature" => array(
                array(Value::$xmlrpcStruct, Value::$xmlrpcInt),
                array(Value::$xmlrpcStruct, Value::$xmlrpcInt, $xmlrpcString)
            )
        )
    ),
    false
);
$srv->functions_parameters_type = 'phpvals';
$srv->exception_handling = 1;
$srv->service();
----

There are a few things to keep in mind when using this calling convention:

* to return an xml-rpc error, the method handler function must return an instance of Response. The only other way for the
  server to know when an error response should be served to the client is to throw an exception and set the server's
  `exception_handling` member var to 1 (as shown above);

* to return a base64 value, the method handler function must encode it on its own, creating an instance of a Value
  object;

* to fine-tune the encoding to xml-rpc types of the method handler's result, you can use the Server's
  `$phpvals_encoding_options` property

* the method handler function cannot determine the name of the xml-rpc method it is serving, unlike manual-conversion
  handler functions that can retrieve it from the Request object;

* when receiving nested parameters, the method handler function has no way to distinguish a php string that was sent as
  base64 value from one that was sent as a string value;

* this has a direct consequence on the support of `system.multicall`: a method whose signature contains datetime or base64
  values will not be available to multicall calls;

* last but not least, the direct parsing of xml to php values is faster than using xmlrpcvals, and allows the library
  to handle much bigger messages without allocating all available server memory or smashing PHP recursive call stack.

==== Delaying the server response

You may want to construct the server, but for some reason not fulfill the request immediately (security verification,
for instance). If you omit to pass to the constructor the dispatch map or pass it a second argument of `0` this will
have the desired effect. You can then use the `service` method of the server instance to service the request. For example:

[source, php]
----
use PhpXmlRpc\Server;

$s = new Server($myDispMap, 0); // second parameter = 0 prevents automatic servicing of request

// ... some code that does other stuff here

$s->service();
----

Note that the `service` method will print the complete result payload to screen and send appropriate HTTP headers back to
the client, but also return the response object. This permits further manipulation of the response, possibly in
combination with output buffering.

To prevent the server from sending HTTP headers back to the client, you can pass a second parameter with a value of
`TRUE` to the `service` method (the first parameter being the payload of the incoming request; it can be left empty to
use automatically the HTTP POST body). In this case, the response payload will be returned instead of the response object.

Xmlrpc requests retrieved by other means than HTTP POST bodies can also be processed. For example:

[source, php]
----
use PhpXmlRpc\Server;

$srv = new Server(); // not passing a dispatch map prevents automatic servicing of request

// ... some code that does other stuff here, including setting dispatch map into server object

$resp = $srv->service($xmlrpc_request_body, true); // parse a variable instead of POST body, retrieve response payload

// ... some code that does other stuff with xml response $resp here
----

==== Modifying the server's behaviour

A couple of methods / class properties are available to modify the behaviour of the server. The only way to take
advantage of their existence is by usage of a delayed server response (see above).

===== setDebug() [[setdebug]]

This function controls weather the server is going to echo debugging messages back to the client as comments in response
body. Valid values: 0,1,2,3, with 1 being the default. At level 0, no debug info is returned to the client. At level 2,
the complete client request is added to the response, as part of the xml comments. At level 3, a new PHP error handler
is set when executing user functions exposed as server methods, and all non-fatal errors are trapped and added as comments
into the response.

===== $allow_system_funcs

Default value: `TRUE`. When set to `FALSE`, disables support for `System.xxx` functions in the server. It might be useful
e.g. if you do not wish the server to respond to requests to `System.ListMethods`.

===== $compress_response

When set to `TRUE`, enables the server to take advantage of HTTP compression, otherwise disables it. Responses will be
transparently compressed, but only when an xml-rpc client declares its support for compression in the HTTP headers of the
request.

Note that the ZLIB php extension must be installed for this to work. If it is, `$compress_response` will default to TRUE.

===== $exception_handling [[exception_handling]]

This property controls the behaviour of the server when an exception is thrown by a method handler php function. Valid
values: 0,1,2, with 0 being the default. At level 0, the server catches the exception and returns an 'internal error'
xml-rpc response; at 1 it catches the exception and returns an xml-rpc response with the error code and error message
corresponding to the exception that was thrown; at 2, the exception is floated to the upper layers in the code.

===== $response_charset_encoding

Charset encoding to be used for responses (only affects string values).

If it can, the server will convert the generated response from internal_encoding to the intended one.

Valid values are: a supported xml encoding (only `UTF-8` and `ISO-8859-1` at present, unless mbstring is enabled), `null`
(leave charset unspecified in response and convert output stream to US_ASCII), or `auto` (use client-specified charset
encoding or same as request if request headers do not specify it (unless request is US-ASCII: then use library default
anyway).

==== Troubleshooting server's method handlers

A tried-and-true way to debug a piece of php code is to add a `var_dump()` call, followed by `die()`, at the exact place
where one thinks things are going wrong. However, doing so in functions registered as xml-rpc method handlers is not as
handy as it is for web pages: for a start a valid xml-rpc request is required to trigger execution of the code, which forces
usage of an xml-rpc client instead of a plain browser; then, the xml-rpc client in use might lack the capability of displaying
the received payload if it is not valid xml-rpc xml.

In order to overcome this issue, two helper methods are available in the Server class: `error_occurred($message)` and
`debugmsg($message)`. The given messages will be added as xml comments, using base64 encoding to avoid breaking xml,
into the server's responses, provided the server's debug level has been set to at least 1 for debug messages and 2 for
error messages. The xml-rpc client provided with this library can handle the specific format used by those xml comments,
and will display their decoded value when it also has been set to use an appropriate debug level.

=== Fault reporting [[faults]]

In order to avoid conflict with error codes used by the library, fault codes used by your servers' method handlers should
start at the value indicated by the variable `PhpXmlRpc::$xmlrpcerruser` + 1.

Standard errors returned by the library include:

`1` Unknown method:: Returned if the server was asked to dispatch a method it didn't know about

`2` Invalid return payload:: This error is actually generated by the client, not server, code, but signifies that a
    server returned something it couldn't understand. A more detailed error report is sometimes added onto the end of
    the phrase above.

`3` Incorrect parameters:: This error is generated when the server has signature(s) defined for a method, and the
    parameters passed by the client do not match any of signatures.

`4` Can't introspect: method unknown:: This error is generated by the builtin system.* methods when any kind of
    introspection is attempted on a method undefined by the server.

`5` Didn't receive 200 OK from remote server:: This error is generated by the client when a remote server doesn't return
    HTTP/1.1 200 OK in response to a request. A more detailed error report is added onto the end of the phrase above.

`6` No data received from server:: This error is generated by the client when a remote server returns HTTP/1.1 200 OK in
    response to a request, but no response body follows the HTTP headers.

`7` No SSL support compiled in:: This error is generated by the client when trying to send a request with HTTPS and the
    CURL extension is not available to PHP.

`8` CURL error:: This error is generated by the client when trying to send a request with HTTPS and the HTTPS
    communication fails.

`9-14, 18` multicall errors:: These errors are generated by the server when something fails inside a system.multicall request.

`15` Invalid request payload:: ...

`16` No CURL support compiled in:: ...

`17` Internal server error:: ...

`19` No HTTP/2 support compiled in:: ...

`100-` XML parse errors:: Returns 100 plus the XML parser error code for the fault that occurred. The faultString returned
    explains where the parse error was in the incoming XML stream.

=== Reserved methods [[reservedmethods]]

In order to extend the functionality offered by XML-RPC servers without impacting on the protocol, reserved methods are
supported.

All methods starting with __system.__ are considered reserved by the server. PHP for XML-RPC itself provides four
special methods, detailed in this chapter.

Note that all server objects will automatically respond to clients querying these methods, unless the property
`$allow_system_funcs` has been set to false before calling the `service()` method. This might pose a security risk
if the server is exposed to public access, e.g. on the internet.

==== system.getCapabilities

This method lists all the capabilities that the XML-RPC server has: the (more or less standard) extensions to the xml-rpc
spec that it implements. It takes no parameters.

==== system.listMethods

This method may be used to enumerate the methods implemented by the XML-RPC server.

The system.listMethods method requires no parameters. It returns an array of strings, each of which is the name of
a method implemented by the server.

==== system.methodSignature [[sysmethodsig]]

This method takes one parameter, the name of a method implemented by the XML-RPC server.

It returns an array of possible signatures for this method. A signature is an array of types. The first of these types
is the return type of the method, the rest are parameters.

Multiple signatures (i.e. overloading) are permitted: this is the reason that an array of signatures is returned by this
method.

Signatures themselves are restricted to the top level parameters expected by a method. For instance if a method expects
one array of structs as a parameter, and it returns a string, its signature is simply "string, array". If it expects
three integers, its signature is "string, int, int, int".

For parameters that can be of more than one type, the `undefined` string is supported.

If no signature is defined for the method, a not-array value is returned. Therefore, this is the way to test for a
non-signature, if $resp below is the response object from a method call to system.methodSignature:

[source, php]
----
$v = $resp->value();
if ($v->kindOf() != "array") {
    // then the method did not have a signature defined
}
----

See the __demo/client/introspect.php__ demo included in this distribution for an example of using this method.

==== system.methodHelp [[sysmethhelp]]

This method takes one parameter, the name of a method implemented by the XML-RPC server.

It returns a documentation string describing the use of that method. If no such string is available, an empty string is
returned.

The documentation string may contain HTML markup.

==== system.multicall

This method takes one parameter, an array of 'request' struct types. Each request struct must contain a `methodName`
member of type string and a `params` member of type array, and corresponds to the invocation of the corresponding method.

It returns a response of type array, with each value of the array being either an error struct (containing the `faultCode`
and `faultString` members) or the successful response value of the corresponding single method call.

=== Global configuration [[globalvars]]

Many static variables are defined in the `PhpxmlRpc\PhpXmlRpc` class and other classes. Some of those are meant to be
used as constants (and modifying their value might cause unpredictable behaviour), while some others can be modified in
your php scripts to alter the behaviour of either the xml-rpc client and server.

==== $xmlrpc_defencoding [[xmlrpc-defencoding]]

    PhpxmlRpc\PhpXmlRpc::$xmlrpc_defencoding = "UTF8"

This variable defines the character set encoding that will be used by the xml-rpc client and server to decode the
received messages, when a specific charset declaration is not found (in the messages sent non-ascii chars are always
encoded using character references, so that the produced xml is valid regardless of the charset encoding assumed).

Allowed values: 'UTF8', 'ISO-8859-1', 'ASCII'.

Note that the appropriate RFC actually mandates that XML received over HTTP without indication of charset encoding be
treated as US-ASCII, but many servers and clients 'in the wild' violate the standard, and assume the default encoding is
UTF-8.

==== $xmlrpc_internalencoding

    PhpxmlRpc\PhpXmlRpc::$xmlrpc_internalencoding = "UTF-8"

This variable defines the character set encoding that the library uses to transparently encode into valid XML the
xml-rpc values created by the user and to re-encode the received xml-rpc values when it passes them to the PHP application.
It only affects xml-rpc values of string type. It is a separate value from `$xmlrpc_defencoding`, allowing e.g. to send/receive
xml messages encoded on-the-wire in US-ASCII and process them as UTF-8. It defaults to the character set used internally
by PHP (unless you are running an MBString-enabled installation), so you should change it only in special situations, if
e.g. the string values exchanged in the xml-rpc messages are directly inserted into / fetched from a database
configured to return non-UTF8 encoded strings to PHP. Example usage:

[source, php]
----
use PhpXmlRpc\Value;

$latin1String = utf8_decode('Hélène'); // This is quite contrived. It is done because the asciidoc manual is saved in UTF-8...
$v = new Value($latin1String);
PhpxmlRpc\PhpXmlRpc::$xmlrpc_internalencoding = 'ISO-8859-1'; // Feel free to set this as early as possible
$xmlSnippet = $v->serialize(); // The xml-rpc value will be correctly serialized as the french name
----

==== $xmlpc_double_precision

The number of decimal digits used to serialize Double values. This is a requirement stemming from

==== $xmlrpcName

    PhpxmlRpc\PhpXmlRpc::$xmlrpcName = "XML-RPC for PHP"

The string representation of the name of the PHPXMLRPC library. It is used by the Client for building the User-Agent
HTTP header that is sent with every request to the server. You can change its value if you need to customize the User-Agent
string.

==== $xmlrpcVersion

    PhpxmlRpc\PhpXmlRpc::$xmlrpcVersion = "4.9.3"

The string representation of the version number of the PHPXMLRPC library in use. It is used by the Client for
building the User-Agent HTTP header that is sent with every request to the server. You can change its value if you need
to customize the User-Agent string.

==== $xmlrpc_null_extension

    PhpxmlRpc\PhpXmlRpc::$xmlrpc_null_extension = FALSE

When set to `TRUE`, the lib will enable support for the `<NIL/>` (and `<EX:NIL/>`) xml-rpc value, as per the extension to
the standard proposed here. This means that `<NIL>` and `<EX:NIL/>` tags received will be parsed as valid
xml-rpc, and the corresponding xmlrpcvals will return "null" for scalarTyp().

==== $xmlrpc_null_apache_encoding

    PhpxmlRpc\PhpXmlRpc::$$xmlrpc_null_apache_encoding = FALSE

When set to `TRUE`, php NULL values encoded into Value objects will get serialized using the `<EX:NIL/>` tag instead of
`<NIL/>`. Please note that both forms are always accepted as input regardless of the value of this variable.

=== Helper classes and functions [[helpers]]

PHPXMLRPC contains some helper classes which you can use to make processing of XML-RPC requests easier.

==== Date handling

The XML-RPC specification has this to say on dates:

[quote]
____
Don't assume a timezone. It should be specified by the server in its documentation what assumptions it makes about
timezones.
____

Unfortunately, this means that date processing isn't straightforward. Although XML-RPC uses ISO 8601 format dates, it
doesn't use the timezone specifier.

We strongly recommend that in every case where you pass dates in XML-RPC calls, you use UTC (GMT) as your timezone. Most
computer languages include routines for handling GMT times natively, and you won't have to translate between timezones.

For more information about dates, see http://www.uic.edu/year2000/datefmt.html[ISO 8601: The Right Format for Dates],
which has a handy link to a PDF of the ISO 8601 specification. Note that XML-RPC uses exactly one of the available
representations: `CCYYMMDDTHH:MM:SS`.

===== iso8601_encode [[iso8601encode]]

    string iso8601_encode(string $time_t, int $utc = 0)

Returns an ISO 8601 formatted date generated from the UNIX timestamp $time_t, as returned by the PHP function `time()`.

The argument $utc can be omitted, in which case it defaults to `0`. If it is set to `1`, then the function corrects the
time passed in for UTC. Example: if you're in the GMT-6:00 timezone and set $utc, you will receive a date representation
six hours ahead of your local time.

The included demo program __demo/client/vardemo.php__ includes a demonstration of this function.

===== iso8601_decode [[iso8601decode]]

    int iso8601_decode(string $isoString, int $utc = 0)

Returns a UNIX timestamp from an ISO 8601 encoded time and date string passed in. If $utc is `1` then $isoString is assumed
to be in the UTC timezone, and thus the result is also UTC: otherwise, the timezone is assumed to be your local timezone
and you receive a local timestamp.

==== Decoding xml

    Value | Request | Response Encoder::decodeXml(string $xml, array $options)

Decodes the xml representation of either an xml-rpc request, response or single value, returning the corresponding
phpxmlrpc object, or `FALSE` in case of an error.

The options parameter is optional. If specified, it must consist of an array of options to be enabled in the
decoding process. At the moment, no option is supported.

Example:
[source, php]
----
$text = '<value><array><data><value>Hello world</value></data></array></value>';
$val = $encoder::decodeXml($text);
if ($val) echo 'Found a value of type ' . $val->kindOf(); else echo 'Found invalid xml';
----

=== Errors and Logging [[logging]]

Many of the classes in this library by default use the php error logging facilities to log errors in case there
is some unexpected but non-fatal event happening, such as f.e. when an invalid xml-rpc request or response are received.
Going straight to the log instead of triggering a php warning or error has the advantage of not breaking the xml-rpc
output when the issue is happening within the context of an xmlrpc-server and `display_errors` is enabled.

In case things are not going as you expect, please check the error log first for the presence of any messages from
PHPXMLRPC which could be useful in troubleshooting what is going on under the hood.

You can customize the way error messages are traced via the static method `setLogger` available for the classes
`Client`, `Encoder`, `Request`, `Server` and `Value`. Keep in mind that for the moment, classes `Charset`, `HTTP` and
`XMLParser` do not allow the same customization without hacking the `PhpXmlRpc\Logger` class. Last but not least, be
aware that the same Logger is also responsible for echoing to screen the debug messages produced by the Client when its
debug level has been set; this allows to customize the debugging process in the same way.

=== Transferring PHP objects over XML-RPC

In case there is a (real) need to transfer php object instances over XML-RPC, the "usual" way would be to use a `serialize`
call on the sender side, then transfer the serialized string using a base64 xml-rpc value, and call `unserialize` on the
receiving side.

The phpxmlrpc library does offer an alternative method, which might offer marginally better performances and ease of use,
by usage of  `PhpXmlRpc\Encoder::encode` and `PhpXmlRpc\Encoder::decode`:

. on the sender side, encode the desired object using option 'encode_php_objs'. This will lead to the creation of an
  xml-rpc struct value with an extra xml attribute: "php_class"

. on the receiver side, decode the received Value using option 'decode_php_objs'. The xml-rpc struct with the extra
  attribute will be converted back into an object of the desired class instead of an array

____WARNING__:__ please take extreme care before enabling the 'decode_php_objs' option: when php objects are rebuilt from
the received xml, their constructor function will be silently invoked. This means that you are allowing the remote end
to trigger execution of uncontrolled PHP code on your server, opening the door to code injection exploits. Only
enable this option when you trust completely the remote server/client. DO NOT USE THIS WITH UNTRUSTED USER INPUT

Note also that there are multiple limitations to this: the same PHP class definition must be available on both ends of
the communication; the class constructor will be called but with no parameters at all, and methods such as `__unserialize`
or `__wakeup` will not be called. Also, if a different toolkit than the phpxmlrpc library is used on the receiving side,
it might reject the generated xml as invalid.

=== Code generation, Proxy objects & co.

For the extremely lazy coder, helper functions have been added that allow to convert a php function into an xml-rpc method,
and a remotely exposed xml-rpc method into a local php function - or a set of xml-rpc methods into a php class. Note that these come with many caveat.

[[wrap_xmlrpc_method]]
==== wrap_xmlrpc_method

    string wrap_xmlrpc_method($client, $methodname, $extra_options)

Given an xml-rpc server and a method name, creates a php wrapper function that will call the remote method and return
results using native php types for both params and results. The generated php function will return a Response object
for failed xml-rpc calls.

The server must support the `system.methodSignature` xml-rpc method call for this function to work.

The client param must be a valid Client object, previously created with the address of the target xml-rpc server, and to
which the preferred communication options have been set.

The optional parameters can be passed as array key,value pairs in the extra_options param.

The signum optional param has the purpose
of indicating which method signature to use, if the given server
method has multiple signatures (defaults to 0).

The timeout and protocol optional params are the same as in the Client::send() method.

If set, the optional new_function_name parameter indicates which name should be used for the generated function. In case
it is not set the function name will be auto-generated.

If the `return_source` optional parameter is
set, the function will return the php source code to build the wrapper
function, instead of evaluating it (useful to save the code and use it
later as stand-alone xml-rpc client).

If the `encode_php_objs` optional parameter is
set, instances of php objects later passed as parameters to the newly
created function will receive a 'special' treatment that allows the
server to rebuild them as php objects instead of simple arrays. Note
that this entails using a "slightly augmented" version of the xml-rpc
protocol (i.e. using element attributes), which might not be understood
by xml-rpc servers implemented using other libraries.

If the `decode_php_objs` optional parameter is
set, instances of php objects that have been appropriately encoded by
the server using a coordinate option will be deserialized as php
objects instead of simple arrays (the same class definition should be
present server side and client side).

__Note that this might pose a security risk__,
since in order to rebuild the object instances their constructor
method has to be invoked, and this means that the remote server can
trigger execution of unforeseen php code on the client: not really a
code injection, but almost. Please enable this option only when you
trust the remote server.

In case of an error during generation of the wrapper function,
FALSE is returned, otherwise the name (or source code) of the new
function.

Known limitations: server must support
system.methodsignature for the wanted xml-rpc
method; for methods that expose multiple signatures, only one can be
picked; for remote calls with nested xml-rpc params, the caller of the
generated php function has to encode on its own the params passed to
the php function if these are structs or arrays whose (sub)members
include values of type base64.

Note: calling the generated php function 'might' be slow: a new
xml-rpc client is created on every invocation and an xmlrpc-connection
opened+closed. An extra 'debug' param is appended to the parameter
list of the generated php function, useful for debugging
purposes.

Example usage:

[source, php]
----
use PhpXmlRpc\Client;

$c = new Client('https://phpxmlrpc.sourceforge.net/server.php');

$function = wrap_xmlrpc_method($client, 'examples.getStateName');

if (!$function)
    die('Cannot introspect remote method');
else {
    $stateno = 15;
    $statename = $function($a);
    // NB: in real life, you should make sure you escape the received data with `htmlspecialchars` when echoing it as html
    if (is_a($statename, 'Response')) { // call failed
        echo 'Call failed: '.$statename->faultCode().'. Calling again with debug on';
        $function($a, true);
    }
    else
      echo "OK, state nr. $stateno is $statename";
}
----

==== wrap_php_function [[wrap_php_function]]

    array wrap_php_function(string $funcname, string $wrapper_function_name, array $extra_options)

Given a user-defined PHP function, create a PHP 'wrapper' function that can be exposed as xml-rpc method from a Server
object and called from remote clients, and return the appropriate definition to be added to a server's dispatch map.

The optional `$wrapper_function_name` specifies the name that will be used for the auto-generated function.

Since php is a typeless language, to infer types of input and output parameters, it relies on parsing the phpdoc-style
comment block associated with the given function. Usage of xml-rpc native types (such as datetime.dateTime.iso8601 and
base64) in the docblock @param tag is also allowed, if you need the php function to receive/send data in that particular
format (note that base64 encoding/decoding is transparently carried out by the lib, while datetime values are passed
around as strings).

Known limitations: only works for user-defined functions, not for PHP internal functions (reflection does not support
retrieving number/type of params for those); the wrapped php function will not be able to programmatically return an
xml-rpc error response.

If the `return_source` optional parameter is set, the function will return the php source code to build the wrapper
function, instead of evaluating it (useful to save the code and use it
later in a stand-alone xml-rpc server). It will be in the stored in the
`source` member of the returned array.

If the `suppress_warnings` optional parameter
is set, any runtime warning generated while processing the
user-defined php function will be caught and not be printed in the
generated xml response.

If the extra_options array contains the `encode_php_objs` value, wrapped functions returning php objects will generate
"special" xml-rpc responses: when the decoding of those responses is carried out by this same lib, using the
appropriate param in php_xmlrpc_decode(), the objects will be rebuilt.

In short: php objects can be serialized, too (except for their resource members), using this function. Other libs might
choke on the very same xml that will be generated in this case (i.e. it has a nonstandard attribute on struct element tags)

If the `decode_php_objs` optional parameter is set, instances of php objects that have been appropriately encoded by
the client using a coordinate option will be deserialized and passed to the user function as php objects instead of simple
arrays (the same class definition should be present server side and client side).

__Note that this might pose a security risk__, since in order to rebuild the object instances their constructor
method has to be invoked, and this means that the remote client can trigger execution of unforeseen php code on the
server: not really a code injection, but almost. Please enable this option only when you trust the remote clients.

Example usage:

[source, php]
----
use PhpXmlRpc\Server;

/**
* State name from state number decoder. NB: do NOT remove this comment block.
* @param integer $stateno the state number
* @return string the name of the state (or error description)
*/
function findstate($stateno)
{
    $stateNames = array(...);
    if (isset($stateNames[$stateno-1]))
    {
        return $stateNames[$stateno-1];
    }
    else
    {
        return "I don't have a state for the index '" . $stateno . "'";
    }
}

// wrap php function, build xml-rpc server
$methods = array();
$findstate_sig = wrap_php_function('findstate');
if ($findstate_sig)
    $methods['examples.getStateName'] = $findstate_sig;
$srv = new Server($methods);
----

== Performances [[performances]]

Although the library is not designed to be the most memory-efficient nor the most fast possible implementation of the
xml-rpc protocol, care is taken not to introduce unnecessary bloat.

The __extras/benchmark.php__ file is used to assess the changes to performance for each new release, and to compare the
results obtained by executing the same operation using different options, such as f.e. manual vs. automatic encoding of
php values to Value objects.

=== Performance optimization tips

* avoid spending time converting the received xml into Value objects, instead have the library pass primitive php values
  directly to your application by setting `+$client->return_type = XMLParser::RETURN_PHP+` and
  `+$server->functions_parameters_type = XMLParser::RETURN_PHP+`

* reduce the encoding of non-ascii characters to character entity references by setting both `PhpXmlRpc::$xmlrpc_internalencoding`
  and `+$client->request_charset_encoding+` / `+$server->response_charset_encoding+` to 'UTF-8'

* if the server you are communicating with does support it, and the requests you are sending are big, or the network slow,
  you should enable compression of the requests, via setting `+$client->request_compression = true+`

* set `+$server->debug = 0+`

* boxcar multiple xml-rpc calls into a single http request by making usage of the `system.multicall` capability. Just
  passing in an array of Request objects to `+$client->send()+` is usually enough. If the server you are talking to does
  not support `system.multicall`, see the __demo/client/parallel.php__ example instead for how to send multiple requests
  in parallel using cURL

== Upgrading [[upgrading]]

If you are upgrading to version 4 from version 3 or earlier you have two options:

1. adapt your code to the new API (all changes needed are described in https://github.com/gggeek/phpxmlrpc/blob/master/doc/api_changes_v4.md)

2. use instead the *compatibility layer* which is provided. Instructions and pitfalls described at https://github.com/gggeek/phpxmlrpc/blob/master/doc/api_changes_v4.md#enabling-compatibility-with-legacy-code

In any case, read carefully the docs available online and report back any undocumented issue using GitHub.

=== Removed from the library [[deprecated]]

The following two functions have been deprecated in version 1.1 of the library, and removed in version 2, in order to
avoid conflicts with the PHP xml-rpc extension, which also defines two functions with the same names.

To ease the transition to the new naming scheme and avoid breaking existing implementations, the following scheme has
been adopted:

* If EPI-XMLRPC is not active in the current PHP installation, the constant `XMLRPC_EPI_ENABLED` will be set to '0'


* If EPI-XMLRPC is active in the current PHP installation, the constant `XMLRPC_EPI_ENABLED` will be set to '1'

The following documentation is kept for historical reference:

==== xmlrpc_decode [[xmlrpcdecode]]

    mixed mlrpc_decode(Value $xmlrpc_val)

Alias for `php_xmlrpc_decode`.

==== xmlrpc_encode [[xmlrpcencode]]

    Value xmlrpc_encode(mixed $phpval)

Alias for `php_xmlrpc_encode`.


== Bundled debugger [[debugger]]

A webservice debugger is included in the library to help during development and testing.

=== Debugger setup

**NB** to avoid turning your webserver into an open relay for http calls, please keep the debugger outside your
webserver's document root by default / in production deployments!

In order to make usage of the debugger, you will need to have a webserver configured to run php code, and make it serve
the `/debugger` folder within the library.

The simplest method is to start the php command-line webserver, but if you do so, you should make use of the experimental
multi-process setup. Ex:

    cd debugger; PHP_CLI_SERVER_WORKERS=2 php -S 127.0.0.1:8081

then access the debugger by pointing your browser at __http://127.0.0.1:8081__

=== Debugger usage

The interface should be self-explicative enough to need little documentation.

image::debugger.gif[,,,,align="center"]

To make sure that the debugger is working properly, you can use it make f.e. a "list available methods" call against the
public demo server available at: Address: __gggeek.altervista.org__, Path: __/sw/xmlrpc/demo/server/server.php__

The most useful feature of the debugger is without doubt the "Show debug info" option. It allows to have a screen dump
of the complete http communication between client and server, including the http headers as well as the request and
response payloads, and is invaluable when troubleshooting problems with charset encoding, authentication or http
compression.

=== Using the debugger against a local server

If the webserver used to run the debugger is prevented from making http calls to the internet at large for security or
connectivity reasons, one way to make sure that it is working as expected and get acquainted with the library's workings
is to test against the "demo" server which comes bundled with the library:

- install the library using the Composer option `--prefer-install=source`, to make sure the demo files are also downloaded
- make sure both the `/debugger` and the `/demo` folders are within your webserver's root folder, e.g. run
  `PHP_CLI_SERVER_WORKERS=2 php -S 127.0.0.1:8081` from the root of the phpxmlrpc library
- access the debugger at __http://127.0.0.1:8081/debugger__ and use it with Address: __127.0.0.1__,
  Path: __/demo/server/server.php__

=== Debugger extension

The debugger can take advantage of the JSXMLRPC library's visual editor component to allow easy mouse-driven construction
of the payload for remote methods. To enable the extra functionality, it has have to be downloaded separately and copied
to the debugger directory: @TODO...


== Running tests [[tests]]

The recommended way to run the library's test suite is via the provided Docker containers.
A handy shell script is available that simplifies usage of Docker.

The full sequence of operations is:

    ./tests/ci/vm.sh build
    ./tests/ci/vm.sh start
    ./tests/ci/vm.sh runtests
    ./tests/ci/vm.sh stop

    # and, once you have finished all testing related work:
    ./tests/ci/vm.sh cleanup

By default, tests are run using php 7.4 in a Container based on Ubuntu 20 Focal.
You can change the version of PHP and Ubuntu in use by setting the environment variables PHP_VERSION and UBUNTU_VERSION
before building the Container.

To generate the code-coverage report, run `./tests/ci/vm.sh runcoverage`

Note: to reduce the size of the download, the test suite is not part of the default package installed with Composer.
In order to have it onboard, install the library using Composer option `--prefer-install=source`.


== Frequently Asked Questions [[qanda]]

=== My client returns "XML-RPC Fault #2: Invalid return payload: enable debugging to examine incoming payload": what should I do?

The response you are seeing is a default error response that the client object returns to the php application when the
server did not respond to the call with a valid xml-rpc response.

The most likely cause is that you are not using the correct URL when creating the client object, or you do not have
appropriate access rights to the web page you are requesting, or some other common http misconfiguration.

To find out what the server is really returning to your client, you have to enable the debug mode of the client, using
`$client->setDebug(1)`. You can also inspect the http connection information in `$response->httpResponse()` - see below

=== How can I save to a file the xml of the xml-rpc responses received from servers?

If what you need is to save the responses received from the server as xml, you have multiple options:

1 - use the Response's `httpResponse` method

[source, php]
----
$resp = $client->send($msg);
if (!$resp->faultCode())
    $data_to_be_saved = $resp->httpResponse()['raw_data'];
----

Note that, while the data saved this way is an accurate copy of what is received from the server, it might not match what
gets parsed into the response's value, as there is some filtering involved, such as stripping of comments junk from
the end of the message, character set conversion, etc...

Note also that, in the future, this might need some debug mode to be enabled in order to work.

2 - use the `serialize` method on the Response object.

[source, php]
----
$resp = $client->send($msg);
if (!$resp->faultCode())
  $data_to_be_saved = $resp->serialize();
----

Note that this will not be 100% accurate, since the xml generated by the response object can be different from the xml
received, especially if there is some character set conversion involved, or such (e.g. if you receive an empty string tag
as "<string/>", `serialize()` will output "<string></string>"), or if the server sent back as response something invalid (in
which case the xml generated client side using serialize() will correspond to the error response generated
internally by the lib).

3 - set the client object to return the raw xml received instead of the decoded objects:

[source, php]
----
$client = new Client($url);
$client->return_type = 'xml';
$resp = $client->send($msg);
if (!$resp->faultCode())
    $data_to_be_saved = $resp->value();
----

Note that using this method the xml response will not be parsed at all by the library, only the http communication
protocol will be checked. This means that xml-rpc responses sent by the server that would have generated an error
response on the client (e.g. malformed xml, responses that have faultCode set, etc...) now will not be flagged as
invalid, and you might end up saving not valid xml but random junk...

=== How can I save to a file the xml of the xml-rpc requests/responses generated from the library?

Classes `Request`, `Response` and `Value` all have a method `serialize()` which can be used to obtain the xml representation
of their value.

Note that, if what you want is to check with absolute certainty what is being sent over the wire, you are better off
using the `setDebug` method in both the client and the server.

=== Is there any limitation on the size of the requests / responses that can be successfully sent?

Yes. But there is no hard figure to be given; it most likely will depend on the version of PHP in usage and its configuration.

Keep in mind that this library is not optimized for speed nor for memory usage. Better alternatives exist when there are
strict requirements on throughput or resource usage, such as the php native xmlrpc extension (see the PHP manual for
more information).

Keep in mind also that HTTP is probably not the best choice in such a situation, and XML is a deadly enemy. CSV formatted
data over socket would be much more efficient. Or rpc protocols Googles' ProtoBuffer.

If you really need to move a massive amount of data around, and you are crazy enough to do it using phpxmlrpc, your best
bet is to bypass usage of the Value objects, at least in the decoding phase, and have the server (or client) object
return to the calling function directly php values (see `Client::return_type` and `Server::functions_parameters_types`
for more details, and the tips in the <<performances>> section).

=== How to send custom XML as payload of a method call

Unfortunately, at the time the XML-RPC spec was designed, support for namespaces in XML was not as ubiquitous as it
became later. As a consequence, no support was provided in the protocol for embedding XML elements from other namespaces
into an xml-rpc request.

To send an XML "chunk" as payload of a method call or response, two options are available: either send the complete XML
block as a string xml-rpc value, or as a base64 value. Since the '<' character in string values is encoded as '&lt;' in
the xml payload of the method call, the XML string will not break the surrounding xml-rpc, unless characters outside the
assumed character set are used. The second method has the added benefits of working independently of the charset
encoding used for the xml to be transmitted, and preserving exactly whitespace, whilst incurring in some extra message
length and cpu load (for carrying out the base64 encoding/decoding).

=== My server (client) returns an error whenever the client (server) returns accented characters

To be documented...

=== Can I use the MS Windows character set?

If the data your application is using comes from a Microsoft application, there are some chances that the character set
used to encode it is CP1252 (the same might apply to data received from an external xml-rpc server/client, but it is quite
rare to find xml-rpc toolkits that encode to CP1252 instead of UTF8). It is a character set which is "almost" compatible
with ISO 8859-1, but for a few extra characters.

PHPXMLRPC only supports the ISO 8859-1 and UTF8 character sets.
The net result of this situation is that those extra characters will not be properly encoded, and will be received at
the other end of the XML-RPC transmission as "garbled data". Unfortunately the library cannot provide real support for
CP1252 because of limitations in the PHP 4 xml parser. Luckily, we tried our best to support this character set anyway,
and, since version 2.2.1, there is some form of support, left commented out in the code.

To properly encode outgoing data that is natively in CP1252, you will have to uncomment all relative code in the file
__xmlrpc.inc__ (you can search for the string "1252"), then set `GLOBALS['xmlrpc_internalencoding']='CP1252';`
Please note that all incoming data will then be fed to your application as UTF-8 to avoid any potential data loss.

=== Does the library support using cookies / http sessions?

In short: yes, but a little coding is needed to make it happen.

The code below uses sessions to e.g. let the client store a value on the server and retrieve it later.

[source, php]
----
use PhpXmlRpc/Request;
use PhpXmlRpc/Value;

$resp = $client->send(new Request('registervalue', array(new Value('foo'), new Value('bar'))));
if (!$resp->faultCode())
{
    $cookies = $resp->cookies();
    if (array_key_exists('PHPSESSID', $cookies)) // nb: make sure to use the correct session cookie name
    {
        $session_id = $cookies['PHPSESSID']['value'];

        // do some other stuff here...

        $client->setcookie('PHPSESSID', $session_id);
        $val = $client->send(new Request('doStuff', array(new Value('foo')));
    }
}
----

Server-side sessions are handled normally like in any other php application. Please see the php manual for more
information about sessions.

NB: unlike web browsers, not all xml-rpc clients support usage of http cookies. If you have troubles with sessions and
control only the server side of the communication, please check with the makers of the xml-rpc client in use.

=== Does the library support following http redirects?

Yes, but only when using cURL for transport.

[source, php]
----
$client->setUseCurl(\PhpXmlRpc\Client::USE_CURL_ALWAYS);
$client->setCurlOptions([CURLOPT_FOLLOWLOCATION => true, CURLOPT_POSTREDIR => 3]);
----

=== Does the library support setting custom cURL options?

Yes. Set `+$client->use_curl = Client::USE_CURL_ALWAYS+` then use the Client method `+$client->setCurlOptions()+`

=== How to enable long-lasting method calls

To be documented...

=== Integration with the PHP xmlrpc extension

In short: for the fastest execution possible, you can enable the php native xmlrpc extension, and use it in conjunction
with phpxmlrpc. The following code snippet gives an example of such integration:

[source, php]
----
/*** client side ***/
$c = new Client('https://phpxmlrpc.sourceforge.net/server.php');

// tell the client to return raw xml as response value
$c->return_type = 'xml';

// let the native xmlrpc extension take care of encoding request parameters
$r = $c->send(xmlrpc_encode_request('examples.getStateName', (int)$_POST['stateno']));

if ($r->faultCode()) {
    // HTTP transport error
    echo 'Got error ' . $r->faultCode();
} else {
    // HTTP request OK, but XML returned from server not parsed yet
    $v = xmlrpc_decode($r->value());
    // check if we got a valid xml-rpc response from server
    if ($v === NULL)
        echo 'Got invalid response';
    else
    // check if server sent a fault response
    if (xmlrpc_is_fault($v))
        echo 'Got xml-rpc fault '.$v['faultCode'];
    else
        echo'Got response: '.htmlentities($v);
}
----

*NB:* Please note that, as of PHP 8.2, the native xmlrpc extension has been moved to Pecl, and it is not bundled in the
stock PHP builds anymore. Moreover, its development has all but ceased, and its usage is discouraged.

=== Substitution of the PHP xmlrpc extension

Yet another interesting situation is when you are using a ready-made php application, that provides support for the
XML-RPC protocol via the native php xmlrpc extension, but the extension is not available on your php install (e.g.
because of shared hosting constraints, or because you are using php 8.2 or later).

Since version 2.1, the PHPXMLRPC library provides a compatibility layer that aims to be 100% compliant with the xmlrpc
extension API. This means that any code written to run on the extension should obtain the exact same results, albeit
using more resources and a longer processing time, using the PHPXMLRPC library and the extension compatibility module.

The module was originally part of the EXTRAS package, available as a separate download from the sourceforge.net website;
it has since become available as Packagist package `phpxmlrpc/polyfill-xmlrpc` and can be found on GitHub at
https://github.com/gggeek/polyfill-xmlrpc

++++++++++++++++++++++++++++++++++++++
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
sgml-namecase-general:t
sgml-general-insert-case:lower
End:
-->
++++++++++++++++++++++++++++++++++++++
